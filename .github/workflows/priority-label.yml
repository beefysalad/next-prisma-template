name: Priority Labeling

on:
  issues:
    types: [opened, edited]

permissions:
  issues: write

jobs:
  priority-label:
    runs-on: ubuntu-latest
    steps:
      - name: Add priority labels based on keywords
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const title = issue.title.toLowerCase();
            const body = (issue.body || '').toLowerCase();
            const text = title + ' ' + body;

            // Define priority keywords
            const priorityKeywords = {
              'critical': [
                'critical', 'urgent', 'emergency', 'blocker', 'blocking',
                'production down', 'data loss', 'security breach', 'crash'
              ],
              'high-priority': [
                'important', 'high priority', 'asap', 'soon',
                'major bug', 'broken feature', 'cannot use'
              ],
              'medium-priority': [
                'should have', 'would like', 'improvement',
                'enhancement', 'moderate'
              ],
              'low-priority': [
                'nice to have', 'minor', 'cosmetic', 'polish',
                'low priority', 'eventually', 'someday'
              ]
            };

            // Check for priority keywords
            let detectedPriority = null;

            // Check in order of priority (critical first)
            for (const [priority, keywords] of Object.entries(priorityKeywords)) {
              if (keywords.some(keyword => text.includes(keyword))) {
                detectedPriority = priority;
                break; // Use the highest priority found
              }
            }

            if (detectedPriority) {
              const existingLabels = issue.labels.map(l => l.name);
              
              // Remove other priority labels first
              const priorityLabels = Object.keys(priorityKeywords);
              const labelsToRemove = priorityLabels.filter(l => 
                l !== detectedPriority && existingLabels.includes(l)
              );
              
              for (const label of labelsToRemove) {
                try {
                  await github.rest.issues.removeLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    name: label
                  });
                } catch (error) {
                  // Label might not exist, ignore
                }
              }
              
              // Add the detected priority label
              if (!existingLabels.includes(detectedPriority)) {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  labels: [detectedPriority]
                });
                
                console.log(`Added ${detectedPriority} label to issue #${issue.number}`);
                
                // Add a comment for critical issues
                if (detectedPriority === 'critical') {
                  const comment = `ðŸš¨ **Critical Priority Detected**

            This issue has been automatically marked as critical based on its content.

            A maintainer will review this issue as soon as possible. If this is a security issue, please also email security@example.com.`;
                  
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    body: comment
                  });
                }
              }
            }
